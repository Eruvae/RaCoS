#include "sdcomm.h"

SDComm sdcomm;

//SD-Command-List
        // Abbreviation         // Index        // Functionality                        Argument        Response
//---------------------------------------------------------------------------------------------------------------
#define GO_IDLE_STATE           0b01000000      // Software reset.                      None(0)         R1
#define SEND_OP_COND            0b01000001      // Initiate initialization process.     None(0)         R1
#define APP_SEND_OP_COND        0b01101001      // Initiate initialization process(SD). Bit 30: HCS     R1
#define SET_BLOCKLEN            0b01010000      // Change R/W block size.               Block length    R1
#define READ_SINGLE_BLOCK       0b01010001      // Read a block.                        Address[31:0]   R1
#define READ_MULTIPLE_BLOCK     0b01010010      // Read multiple blocks.                Address[31:0]   R1
#define WRITE_BLOCK             0b01011000      // Write a block.                       Address[31:0]   R1
#define WRITE_MULTIPLE_BLOCK    0b01011001      // Write multiple blocks.               Address[31:0]   R1

const uint8_t ff = 0xFF;
const uint8_t xff[512] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

SDComm::SDComm()
{
	is_initialized = false;
}

int SDComm::sendCommand(uint8_t command, uint32_t argument, uint8_t crc)
{   
    uint8_t buff[6];
    buff[0] = command;
    *(uint32_t*)&buff[1] = argument;
    buff[5] = crc;

    spiHelper.selectSlave(SD);

    int ret;
    if ((ret = spi_bus.write(buff, 6)) < 6)
    {
    	spiHelper.disableSlaves();
    	return -1;
    }

    int result = -1;
    uint8_t ff = 0xFF;
    for (int i = 0; i < 32; i++)	//wait for response
    {
        uint8_t rec;
        spi_bus.writeRead(&ff, 1, &rec, 1);
        if (rec != 0xFF) // Respond received
        {
            result = rec & 0xFF;
            break;
        }
    }

    spiHelper.disableSlaves();

    return result;
}

int SDComm::init()
{
    // TODO: Might be necessary to change Baudrate/Clock Speed; maybe sleep
	int result = 0xFF;
	for (int i = 0; i < 10 && (result != 0x01 && result != 0x00); i++)
	{
		result = sendCommand(GO_IDLE_STATE, 0, 0x95);
		PRINTF("Result 1: %x\n", result);
	}
	if (result != 0x01 && result != 0x00)
	{
		return -1;
	}
	PRINTF("Result 2: %x\n", result);

	for (int i = 0; i < 100000 && result != 0x00; i++)
	{
		result = sendCommand(SEND_OP_COND, 0);
		PRINTF("Result: %x\n", result);
	}
	PRINTF("Result: %x\n", result);

    if (result == -3)
    {
    	return -3;
    }

    if (sendCommand(SET_BLOCKLEN, 512) != 0x00)
    {
    	return -4;
    }

    is_initialized = true;
    return 0;

}

int SDComm::get_status()
{
	if (!is_initialized)
		return -1;

	return 0;
}

int SDComm::read_sector_segment(uint32_t sector, uint8_t *buf)
{
    int result = -1;

    for (int i = 0; i < 10; i++)
    {
        if (sendCommand(READ_SINGLE_BLOCK, sector<<9, 0xFF) == 0x00) // <<9 == *512
        {
            result = 0;
            break;
        }
    }

    if (result == -1)
    {
    	PRINTF("Failed send RSB-Command\n");
        return -1;
    }

    //result = -1;

    /*uint8_t ff = 0xFF;
    for (int i = 0; i < 1000; i++) {	//wait for ack.
        uint8_t rec;
        spi_bus.writeRead(&ff, 1, &rec, 1);
        //PRINTF("%x", rec & 0xFF);
        if (rec != 0xFF) // Respond received, TODO (maybe): R1
        {
            result = 0;
            break;
        }
    }

    if (result == -1)
    {
    	PRINTF("No acknoledgement.\n");
        spiHelper.disableSlaves();
        return -1;
    }*/

    spiHelper.selectSlave(SD);

    spi_bus.writeRead(xff, 512, buf, 512);

    uint8_t ff = 0xFF;
    spi_bus.write(&ff, 1);                   //false 16-bits crc
    spi_bus.write(&ff, 1);

    spiHelper.disableSlaves();

    return 0;
}

int SDComm::write_sector_segment(uint32_t sector, const uint8_t *buf)
{
    int result = -1;

    for (int i = 0; i < 10; i++)
    {
        if (sendCommand(WRITE_BLOCK, sector<<9, 0xFF) == 0x00) // <<9 == *512
        {
            result = 0;
            break;
        }
    }

    if (result == -1)
    {
        return -1;
    }

    spiHelper.selectSlave(SD);

    spi_bus.write(buf, 512);

    spi_bus.suspendUntilWriteFinished();

    spiHelper.disableSlaves();
    return 0;
}
